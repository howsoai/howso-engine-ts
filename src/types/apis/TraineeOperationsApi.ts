/**
 * Howso API
 * OpenAPI implementation for interacting with the Howso API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
  AnalyzeRequest,
  AppendToSeriesStoreRequest,
  AsyncActionAccepted,
  AutoAblationParams,
  EvaluateRequest,
  EvaluateResponse,
  ImputeRequest,
  ReactAggregateRequest,
  ReactAggregateResponse,
  ReactGroupRequest,
  ReactGroupResponse,
  ReactIntoFeaturesRequest,
  ReactIntoFeaturesResponse,
  ReactRequest,
  ReactResponse,
  ReactSeriesRequest,
  ReactSeriesResponse,
  ReduceDataParams,
  RemoveSeriesStoreRequest,
  SetAutoAnalyzeParamsRequest,
  TrainRequest,
  TrainResponse,
  TraineeWorkflowAttributes,
  TraineeWorkflowAttributesRequest,
} from "../models";
import {
  AnalyzeRequestToJSON,
  AppendToSeriesStoreRequestToJSON,
  AsyncActionAcceptedFromJSON,
  AutoAblationParamsFromJSON,
  AutoAblationParamsToJSON,
  EvaluateRequestToJSON,
  EvaluateResponseFromJSON,
  ImputeRequestToJSON,
  ReactAggregateRequestToJSON,
  ReactAggregateResponseFromJSON,
  ReactGroupRequestToJSON,
  ReactGroupResponseFromJSON,
  ReactIntoFeaturesRequestToJSON,
  ReactIntoFeaturesResponseFromJSON,
  ReactRequestToJSON,
  ReactResponseFromJSON,
  ReactSeriesRequestToJSON,
  ReactSeriesResponseFromJSON,
  ReduceDataParamsToJSON,
  RemoveSeriesStoreRequestToJSON,
  SetAutoAnalyzeParamsRequestToJSON,
  TrainRequestToJSON,
  TrainResponseFromJSON,
  TraineeWorkflowAttributesFromJSON,
  TraineeWorkflowAttributesRequestToJSON,
  TraineeWorkflowAttributesToJSON,
} from "../models";
import * as runtime from "../runtime";

export interface AnalyzeOperationRequest {
  trainee_id: string;
  AnalyzeRequest: AnalyzeRequest;
}

export interface AppendToSeriesStoreOperationRequest {
  trainee_id: string;
  AppendToSeriesStoreRequest: AppendToSeriesStoreRequest;
}

export interface AutoAnalyzeRequest {
  trainee_id: string;
}

export interface EvaluateOperationRequest {
  trainee_id: string;
  EvaluateRequest: EvaluateRequest;
}

export interface GetAutoAblationParamsRequest {
  trainee_id: string;
}

export interface GetWorkflowAttributesRequest {
  trainee_id: string;
  TraineeWorkflowAttributesRequest: TraineeWorkflowAttributesRequest;
}

export interface ImputeOperationRequest {
  trainee_id: string;
  ImputeRequest?: ImputeRequest;
}

export interface ReactOperationRequest {
  trainee_id: string;
  ReactRequest: ReactRequest;
}

export interface ReactAggregateOperationRequest {
  trainee_id: string;
  ReactAggregateRequest: ReactAggregateRequest;
}

export interface ReactGroupOperationRequest {
  trainee_id: string;
  ReactGroupRequest: ReactGroupRequest;
}

export interface ReactIntoFeaturesOperationRequest {
  trainee_id: string;
  ReactIntoFeaturesRequest: ReactIntoFeaturesRequest;
}

export interface ReactSeriesOperationRequest {
  trainee_id: string;
  ReactSeriesRequest: ReactSeriesRequest;
}

export interface ReduceDataRequest {
  trainee_id: string;
  ReduceDataParams: ReduceDataParams;
}

export interface RemoveSeriesStoreOperationRequest {
  trainee_id: string;
  RemoveSeriesStoreRequest: RemoveSeriesStoreRequest;
}

export interface SetAutoAblationParamsRequest {
  trainee_id: string;
  AutoAblationParams: AutoAblationParams;
}

export interface SetAutoAnalyzeParamsOperationRequest {
  trainee_id: string;
  SetAutoAnalyzeParamsRequest: SetAutoAnalyzeParamsRequest;
}

export interface SetWorkflowAttributesRequest {
  trainee_id: string;
  TraineeWorkflowAttributes: TraineeWorkflowAttributes;
}

export interface TrainOperationRequest {
  trainee_id: string;
  TrainRequest?: TrainRequest;
}

/**
 *
 */
export class TraineeOperationsApi extends runtime.BaseAPI {
  /**
   * Analyzes the data to compute the appropriate statistics, uncertainties, and select parameters as appropriate. Note: this is an asynchronous call and may take a non-trivial amount of time. While this operation is in progress, the trainee will not be available.
   * Analyze the trainee
   */
  async analyzeRaw(
    requestParameters: AnalyzeOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AsyncActionAccepted | void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling analyze.",
      );
    }

    if (requestParameters.AnalyzeRequest === null || requestParameters.AnalyzeRequest === undefined) {
      throw new runtime.RequiredError(
        "AnalyzeRequest",
        "Required parameter requestParameters.AnalyzeRequest was null or undefined when calling analyze.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/analyze`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AnalyzeRequestToJSON(requestParameters.AnalyzeRequest),
      },
      initOverrides,
    );

    if (response.status === 204) {
      return new runtime.VoidApiResponse(response);
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
  }

  /**
   * Analyzes the data to compute the appropriate statistics, uncertainties, and select parameters as appropriate. Note: this is an asynchronous call and may take a non-trivial amount of time. While this operation is in progress, the trainee will not be available.
   * Analyze the trainee
   */
  async analyze(
    trainee_id: string,
    AnalyzeRequest: AnalyzeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AsyncActionAccepted | void> {
    const response = await this.analyzeRaw({ trainee_id: trainee_id, AnalyzeRequest: AnalyzeRequest }, initOverrides);
    return await response.value();
  }

  /**
   * Append the given contexts to a series store.
   * Append contexts to series store
   */
  async appendToSeriesStoreRaw(
    requestParameters: AppendToSeriesStoreOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling appendToSeriesStore.",
      );
    }

    if (
      requestParameters.AppendToSeriesStoreRequest === null ||
      requestParameters.AppendToSeriesStoreRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "AppendToSeriesStoreRequest",
        "Required parameter requestParameters.AppendToSeriesStoreRequest was null or undefined when calling appendToSeriesStore.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:write"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/series/append`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AppendToSeriesStoreRequestToJSON(requestParameters.AppendToSeriesStoreRequest),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Append the given contexts to a series store.
   * Append contexts to series store
   */
  async appendToSeriesStore(
    trainee_id: string,
    AppendToSeriesStoreRequest: AppendToSeriesStoreRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.appendToSeriesStoreRaw(
      { trainee_id: trainee_id, AppendToSeriesStoreRequest: AppendToSeriesStoreRequest },
      initOverrides,
    );
  }

  /**
   * Auto-analyze the trainee model re-using all parameters from the previous analyze or set_auto_analyze_params call. If analyze or set_auto_analyze_params has not been previously called, auto_analyze will default to a robust and versatile analysis.
   * Automatically analyze the trainee
   */
  async autoAnalyzeRaw(
    requestParameters: AutoAnalyzeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AsyncActionAccepted | void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling autoAnalyze.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/analyze/auto`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (response.status === 204) {
      return new runtime.VoidApiResponse(response);
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
  }

  /**
   * Auto-analyze the trainee model re-using all parameters from the previous analyze or set_auto_analyze_params call. If analyze or set_auto_analyze_params has not been previously called, auto_analyze will default to a robust and versatile analysis.
   * Automatically analyze the trainee
   */
  async autoAnalyze(
    trainee_id: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AsyncActionAccepted | void> {
    const response = await this.autoAnalyzeRaw({ trainee_id: trainee_id }, initOverrides);
    return await response.value();
  }

  /**
   * Evaluate custom code on cases within a trainee
   * Evaluate custom code on cases within a trainee
   */
  async evaluateRaw(
    requestParameters: EvaluateOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EvaluateResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling evaluate.",
      );
    }

    if (requestParameters.EvaluateRequest === null || requestParameters.EvaluateRequest === undefined) {
      throw new runtime.RequiredError(
        "EvaluateRequest",
        "Required parameter requestParameters.EvaluateRequest was null or undefined when calling evaluate.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:read",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/evaluate`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EvaluateRequestToJSON(requestParameters.EvaluateRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => EvaluateResponseFromJSON(jsonValue));
  }

  /**
   * Evaluate custom code on cases within a trainee
   * Evaluate custom code on cases within a trainee
   */
  async evaluate(
    trainee_id: string,
    EvaluateRequest: EvaluateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EvaluateResponse | AsyncActionAccepted> {
    const response = await this.evaluateRaw(
      { trainee_id: trainee_id, EvaluateRequest: EvaluateRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Return the trainee parameters for auto ablation.
   * Get trainee parameters for auto ablation.
   */
  async getAutoAblationParamsRaw(
    requestParameters: GetAutoAblationParamsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AutoAblationParams>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling getAutoAblationParams.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:read"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/ablation`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => AutoAblationParamsFromJSON(jsonValue));
  }

  /**
   * Return the trainee parameters for auto ablation.
   * Get trainee parameters for auto ablation.
   */
  async getAutoAblationParams(
    trainee_id: string,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AutoAblationParams> {
    const response = await this.getAutoAblationParamsRaw({ trainee_id: trainee_id }, initOverrides);
    return await response.value();
  }

  /**
   * Get trainee workflow attributes.
   * Get trainee workflow attributes
   */
  async getWorkflowAttributesRaw(
    requestParameters: GetWorkflowAttributesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<TraineeWorkflowAttributes>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling getWorkflowAttributes.",
      );
    }

    if (
      requestParameters.TraineeWorkflowAttributesRequest === null ||
      requestParameters.TraineeWorkflowAttributesRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "TraineeWorkflowAttributesRequest",
        "Required parameter requestParameters.TraineeWorkflowAttributesRequest was null or undefined when calling getWorkflowAttributes.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:read"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/attributes`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: TraineeWorkflowAttributesRequestToJSON(requestParameters.TraineeWorkflowAttributesRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) => TraineeWorkflowAttributesFromJSON(jsonValue));
  }

  /**
   * Get trainee workflow attributes.
   * Get trainee workflow attributes
   */
  async getWorkflowAttributes(
    trainee_id: string,
    TraineeWorkflowAttributesRequest: TraineeWorkflowAttributesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<TraineeWorkflowAttributes> {
    const response = await this.getWorkflowAttributesRaw(
      { trainee_id: trainee_id, TraineeWorkflowAttributesRequest: TraineeWorkflowAttributesRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Impute the specified features.  If no features are specified, impute the whole trainee.
   * Impute
   */
  async imputeRaw(
    requestParameters: ImputeOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AsyncActionAccepted | void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling impute.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/impute`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ImputeRequestToJSON(requestParameters.ImputeRequest),
      },
      initOverrides,
    );

    if (response.status === 204) {
      return new runtime.VoidApiResponse(response);
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
  }

  /**
   * Impute the specified features.  If no features are specified, impute the whole trainee.
   * Impute
   */
  async impute(
    trainee_id: string,
    ImputeRequest?: ImputeRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AsyncActionAccepted | void> {
    const response = await this.imputeRaw({ trainee_id: trainee_id, ImputeRequest: ImputeRequest }, initOverrides);
    return await response.value();
  }

  /**
   * React to one or more contexts.
   * React to one or more contexts
   */
  async reactRaw(
    requestParameters: ReactOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReactResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling react.",
      );
    }

    if (requestParameters.ReactRequest === null || requestParameters.ReactRequest === undefined) {
      throw new runtime.RequiredError(
        "ReactRequest",
        "Required parameter requestParameters.ReactRequest was null or undefined when calling react.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:read",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/react`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReactRequestToJSON(requestParameters.ReactRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => ReactResponseFromJSON(jsonValue));
  }

  /**
   * React to one or more contexts.
   * React to one or more contexts
   */
  async react(
    trainee_id: string,
    ReactRequest: ReactRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReactResponse | AsyncActionAccepted> {
    const response = await this.reactRaw({ trainee_id: trainee_id, ReactRequest: ReactRequest }, initOverrides);
    return await response.value();
  }

  /**
   * Compute, store, and/or return specified feature prediction stats such as Mean Decrease in Accuracy (MDA) and feature residuals into the trainee.
   * React Aggregate
   */
  async reactAggregateRaw(
    requestParameters: ReactAggregateOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReactAggregateResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling reactAggregate.",
      );
    }

    if (requestParameters.ReactAggregateRequest === null || requestParameters.ReactAggregateRequest === undefined) {
      throw new runtime.RequiredError(
        "ReactAggregateRequest",
        "Required parameter requestParameters.ReactAggregateRequest was null or undefined when calling reactAggregate.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
        "trainee:read",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/react/aggregate`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReactAggregateRequestToJSON(requestParameters.ReactAggregateRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => ReactAggregateResponseFromJSON(jsonValue));
  }

  /**
   * Compute, store, and/or return specified feature prediction stats such as Mean Decrease in Accuracy (MDA) and feature residuals into the trainee.
   * React Aggregate
   */
  async reactAggregate(
    trainee_id: string,
    ReactAggregateRequest: ReactAggregateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReactAggregateResponse | AsyncActionAccepted> {
    const response = await this.reactAggregateRaw(
      { trainee_id: trainee_id, ReactAggregateRequest: ReactAggregateRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Computes specified data for a grouping of cases either from another trainee or explicitly provided.
   * React to a grouping of cases.
   */
  async reactGroupRaw(
    requestParameters: ReactGroupOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReactGroupResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling reactGroup.",
      );
    }

    if (requestParameters.ReactGroupRequest === null || requestParameters.ReactGroupRequest === undefined) {
      throw new runtime.RequiredError(
        "ReactGroupRequest",
        "Required parameter requestParameters.ReactGroupRequest was null or undefined when calling reactGroup.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:read",
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/react/group`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReactGroupRequestToJSON(requestParameters.ReactGroupRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => ReactGroupResponseFromJSON(jsonValue));
  }

  /**
   * Computes specified data for a grouping of cases either from another trainee or explicitly provided.
   * React to a grouping of cases.
   */
  async reactGroup(
    trainee_id: string,
    ReactGroupRequest: ReactGroupRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReactGroupResponse | AsyncActionAccepted> {
    const response = await this.reactGroupRaw(
      { trainee_id: trainee_id, ReactGroupRequest: ReactGroupRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Calculate conviction and other data and stores them in the model to the specified features.
   * React into features
   */
  async reactIntoFeaturesRaw(
    requestParameters: ReactIntoFeaturesOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReactIntoFeaturesResponse | AsyncActionAccepted | void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling reactIntoFeatures.",
      );
    }

    if (
      requestParameters.ReactIntoFeaturesRequest === null ||
      requestParameters.ReactIntoFeaturesRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "ReactIntoFeaturesRequest",
        "Required parameter requestParameters.ReactIntoFeaturesRequest was null or undefined when calling reactIntoFeatures.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/react/into-features`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReactIntoFeaturesRequestToJSON(requestParameters.ReactIntoFeaturesRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    if (response.status === 204) {
      return new runtime.VoidApiResponse(response);
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => ReactIntoFeaturesResponseFromJSON(jsonValue));
  }

  /**
   * Calculate conviction and other data and stores them in the model to the specified features.
   * React into features
   */
  async reactIntoFeatures(
    trainee_id: string,
    ReactIntoFeaturesRequest: ReactIntoFeaturesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReactIntoFeaturesResponse | AsyncActionAccepted | void> {
    const response = await this.reactIntoFeaturesRaw(
      { trainee_id: trainee_id, ReactIntoFeaturesRequest: ReactIntoFeaturesRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * React to one or more contexts in series.
   * React to one or more contexts in series
   */
  async reactSeriesRaw(
    requestParameters: ReactSeriesOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ReactSeriesResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling reactSeries.",
      );
    }

    if (requestParameters.ReactSeriesRequest === null || requestParameters.ReactSeriesRequest === undefined) {
      throw new runtime.RequiredError(
        "ReactSeriesRequest",
        "Required parameter requestParameters.ReactSeriesRequest was null or undefined when calling reactSeries.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:read",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/react/series`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReactSeriesRequestToJSON(requestParameters.ReactSeriesRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => ReactSeriesResponseFromJSON(jsonValue));
  }

  /**
   * React to one or more contexts in series.
   * React to one or more contexts in series
   */
  async reactSeries(
    trainee_id: string,
    ReactSeriesRequest: ReactSeriesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ReactSeriesResponse | AsyncActionAccepted> {
    const response = await this.reactSeriesRaw(
      { trainee_id: trainee_id, ReactSeriesRequest: ReactSeriesRequest },
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Reduce trained data via influence weight entropy thresholds.
   * Reduce trained data via influence weight entropy thresholds.
   */
  async reduceDataRaw(
    requestParameters: ReduceDataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling reduceData.",
      );
    }

    if (requestParameters.ReduceDataParams === null || requestParameters.ReduceDataParams === undefined) {
      throw new runtime.RequiredError(
        "ReduceDataParams",
        "Required parameter requestParameters.ReduceDataParams was null or undefined when calling reduceData.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:write"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/ablation/reduce_data`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReduceDataParamsToJSON(requestParameters.ReduceDataParams),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Reduce trained data via influence weight entropy thresholds.
   * Reduce trained data via influence weight entropy thresholds.
   */
  async reduceData(
    trainee_id: string,
    ReduceDataParams: ReduceDataParams,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.reduceDataRaw({ trainee_id: trainee_id, ReduceDataParams: ReduceDataParams }, initOverrides);
  }

  /**
   * Removes one or all of the series stored in the trainee.
   * Clear stored series from trainee
   */
  async removeSeriesStoreRaw(
    requestParameters: RemoveSeriesStoreOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling removeSeriesStore.",
      );
    }

    if (
      requestParameters.RemoveSeriesStoreRequest === null ||
      requestParameters.RemoveSeriesStoreRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "RemoveSeriesStoreRequest",
        "Required parameter requestParameters.RemoveSeriesStoreRequest was null or undefined when calling removeSeriesStore.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:write"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/series/remove`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RemoveSeriesStoreRequestToJSON(requestParameters.RemoveSeriesStoreRequest),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Removes one or all of the series stored in the trainee.
   * Clear stored series from trainee
   */
  async removeSeriesStore(
    trainee_id: string,
    RemoveSeriesStoreRequest: RemoveSeriesStoreRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.removeSeriesStoreRaw(
      { trainee_id: trainee_id, RemoveSeriesStoreRequest: RemoveSeriesStoreRequest },
      initOverrides,
    );
  }

  /**
   * Set the trainee parameters for auto ablation.
   * Set trainee parameters for auto ablation.
   */
  async setAutoAblationParamsRaw(
    requestParameters: SetAutoAblationParamsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling setAutoAblationParams.",
      );
    }

    if (requestParameters.AutoAblationParams === null || requestParameters.AutoAblationParams === undefined) {
      throw new runtime.RequiredError(
        "AutoAblationParams",
        "Required parameter requestParameters.AutoAblationParams was null or undefined when calling setAutoAblationParams.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:write"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/ablation`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: AutoAblationParamsToJSON(requestParameters.AutoAblationParams),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Set the trainee parameters for auto ablation.
   * Set trainee parameters for auto ablation.
   */
  async setAutoAblationParams(
    trainee_id: string,
    AutoAblationParams: AutoAblationParams,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.setAutoAblationParamsRaw(
      { trainee_id: trainee_id, AutoAblationParams: AutoAblationParams },
      initOverrides,
    );
  }

  /**
   * Set trainee parameters for auto analysis. Auto-analysis is disabled if this is called without specifying an analyze_threshold.
   * Set trainee parameters for auto analysis
   */
  async setAutoAnalyzeParamsRaw(
    requestParameters: SetAutoAnalyzeParamsOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling setAutoAnalyzeParams.",
      );
    }

    if (
      requestParameters.SetAutoAnalyzeParamsRequest === null ||
      requestParameters.SetAutoAnalyzeParamsRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "SetAutoAnalyzeParamsRequest",
        "Required parameter requestParameters.SetAutoAnalyzeParamsRequest was null or undefined when calling setAutoAnalyzeParams.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/analyze/auto/params`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: SetAutoAnalyzeParamsRequestToJSON(requestParameters.SetAutoAnalyzeParamsRequest),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Set trainee parameters for auto analysis. Auto-analysis is disabled if this is called without specifying an analyze_threshold.
   * Set trainee parameters for auto analysis
   */
  async setAutoAnalyzeParams(
    trainee_id: string,
    SetAutoAnalyzeParamsRequest: SetAutoAnalyzeParamsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.setAutoAnalyzeParamsRaw(
      { trainee_id: trainee_id, SetAutoAnalyzeParamsRequest: SetAutoAnalyzeParamsRequest },
      initOverrides,
    );
  }

  /**
   * Set the trainee workflow attributes.
   * Set the trainee workflow attributes
   */
  async setWorkflowAttributesRaw(
    requestParameters: SetWorkflowAttributesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling setWorkflowAttributes.",
      );
    }

    if (
      requestParameters.TraineeWorkflowAttributes === null ||
      requestParameters.TraineeWorkflowAttributes === undefined
    ) {
      throw new runtime.RequiredError(
        "TraineeWorkflowAttributes",
        "Required parameter requestParameters.TraineeWorkflowAttributes was null or undefined when calling setWorkflowAttributes.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", ["trainee:write"]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/attributes`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: TraineeWorkflowAttributesToJSON(requestParameters.TraineeWorkflowAttributes),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Set the trainee workflow attributes.
   * Set the trainee workflow attributes
   */
  async setWorkflowAttributes(
    trainee_id: string,
    TraineeWorkflowAttributes: TraineeWorkflowAttributes,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.setWorkflowAttributesRaw(
      { trainee_id: trainee_id, TraineeWorkflowAttributes: TraineeWorkflowAttributes },
      initOverrides,
    );
  }

  /**
   * Supply one or more cases to a model.
   * Train a model
   */
  async trainRaw(
    requestParameters: TrainOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<TrainResponse | AsyncActionAccepted>> {
    if (requestParameters.trainee_id === null || requestParameters.trainee_id === undefined) {
      throw new runtime.RequiredError(
        "trainee_id",
        "Required parameter requestParameters.trainee_id was null or undefined when calling train.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken("oauth_ums", [
        "trainee:write",
        "trainee:execute",
      ]);
    }

    const response = await this.request(
      {
        path: `/v2/trainee/{trainee_id}/train`.replace(
          `{${"trainee_id"}}`,
          encodeURIComponent(String(requestParameters.trainee_id)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: TrainRequestToJSON(requestParameters.TrainRequest),
      },
      initOverrides,
    );

    if (response.status === 202) {
      return new runtime.JSONApiResponse(response, (jsonValue) => AsyncActionAcceptedFromJSON(jsonValue));
    }
    return new runtime.JSONApiResponse(response, (jsonValue) => TrainResponseFromJSON(jsonValue));
  }

  /**
   * Supply one or more cases to a model.
   * Train a model
   */
  async train(
    trainee_id: string,
    TrainRequest?: TrainRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<TrainResponse | AsyncActionAccepted> {
    const response = await this.trainRaw({ trainee_id: trainee_id, TrainRequest: TrainRequest }, initOverrides);
    return await response.value();
  }
}
